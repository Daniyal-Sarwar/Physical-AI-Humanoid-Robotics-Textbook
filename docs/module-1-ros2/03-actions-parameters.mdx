---
sidebar_position: 3
title: Actions and Parameters
description: Long-running tasks with feedback and runtime configuration in ROS 2
---

# Actions and Parameters

## Learning Objectives

By the end of this chapter, you will be able to:

- Implement action servers for long-running tasks with feedback
- Create action clients that handle goals, feedback, and results
- Declare, access, and dynamically update node parameters
- Use parameter callbacks for runtime reconfiguration
- Choose between topics, services, and actions appropriately

## Prerequisites

- Completed Chapters 1-2
- Understanding of async/await patterns in Python
- Familiarity with callback-based programming

---

## Actions: Asynchronous Task Execution

### When to Use Actions

Actions are ideal for:
- **Long-running tasks**: Navigation, manipulation, data processing
- **Preemptable operations**: Tasks that may need to be cancelled
- **Progress monitoring**: Operations requiring feedback during execution

### Comparison: Topics vs Services vs Actions

| Feature | Topics | Services | Actions |
|---------|--------|----------|---------|
| Communication | Pub-Sub | Request-Reply | Goal-Feedback-Result |
| Blocking | No | Yes (sync) | No (async) |
| Cancellation | N/A | No | Yes |
| Feedback | N/A | N/A | Yes |
| Use Case | Streaming | Quick queries | Long tasks |

### Action Structure

```
┌─────────────┐                    ┌─────────────┐
│   Client    │ ─── Goal ────────▶ │   Server    │
│             │ ◀── Accepted ───── │             │
│             │                    │             │
│             │ ◀── Feedback ───── │  (working)  │
│             │ ◀── Feedback ───── │             │
│             │ ◀── Feedback ───── │             │
│             │                    │             │
│             │ ◀── Result ─────── │  (done)     │
└─────────────┘                    └─────────────┘
```

---

## Defining an Action

```text title="robot_interfaces/action/Navigate.action"
# Goal: Where to navigate
geometry_msgs/PoseStamped target_pose
float32 max_velocity        # m/s
bool avoid_obstacles

---
# Result: Final outcome
bool success
string message
float32 total_distance      # meters
float32 total_time          # seconds

---
# Feedback: Progress updates
float32 distance_remaining  # meters
float32 estimated_time      # seconds
geometry_msgs/PoseStamped current_pose
string current_state        # PLANNING, MOVING, RECOVERING
```

```cmake title="robot_interfaces/CMakeLists.txt (additions)"
find_package(geometry_msgs REQUIRED)

rosidl_generate_interfaces(${PROJECT_NAME}
  "action/Navigate.action"
  DEPENDENCIES geometry_msgs
)
```

---

## Action Server Implementation

```python title="navigation/navigation_server.py"
import time
import math
import rclpy
from rclpy.node import Node
from rclpy.action import ActionServer, CancelResponse, GoalResponse
from rclpy.callback_groups import ReentrantCallbackGroup
from rclpy.executors import MultiThreadedExecutor

from robot_interfaces.action import Navigate
from geometry_msgs.msg import PoseStamped


class NavigationServer(Node):
    """Action server for robot navigation."""

    def __init__(self):
        super().__init__('navigation_server')
        
        # Allow concurrent callbacks
        self.callback_group = ReentrantCallbackGroup()
        
        self._action_server = ActionServer(
            self,
            Navigate,
            'navigate',
            execute_callback=self.execute_callback,
            goal_callback=self.goal_callback,
            cancel_callback=self.cancel_callback,
            callback_group=self.callback_group
        )
        
        # Current position (simplified)
        self.current_x = 0.0
        self.current_y = 0.0
        
        self.get_logger().info('Navigation server ready')

    def goal_callback(self, goal_request):
        """Decide whether to accept or reject a goal."""
        target = goal_request.target_pose.pose.position
        self.get_logger().info(
            f'Received goal: ({target.x:.2f}, {target.y:.2f})'
        )
        
        # Validate goal
        if goal_request.max_velocity <= 0:
            self.get_logger().warn('Invalid velocity, rejecting goal')
            return GoalResponse.REJECT
        
        return GoalResponse.ACCEPT

    def cancel_callback(self, goal_handle):
        """Decide whether to accept cancellation request."""
        self.get_logger().info('Received cancel request')
        return CancelResponse.ACCEPT

    async def execute_callback(self, goal_handle):
        """Execute the navigation goal."""
        self.get_logger().info('Executing navigation goal...')
        
        # Extract goal parameters
        target = goal_handle.request.target_pose.pose.position
        max_vel = goal_handle.request.max_velocity
        
        # Calculate distance
        dx = target.x - self.current_x
        dy = target.y - self.current_y
        total_distance = math.sqrt(dx*dx + dy*dy)
        
        # Simulate navigation
        feedback_msg = Navigate.Feedback()
        distance_traveled = 0.0
        step_size = max_vel * 0.1  # 100ms steps
        
        start_time = time.time()
        
        while distance_traveled < total_distance:
            # Check for cancellation
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                result = Navigate.Result()
                result.success = False
                result.message = 'Navigation cancelled'
                result.total_distance = distance_traveled
                result.total_time = time.time() - start_time
                self.get_logger().info('Navigation cancelled')
                return result
            
            # Update position
            progress = min(1.0, distance_traveled / total_distance)
            self.current_x = progress * target.x
            self.current_y = progress * target.y
            
            # Send feedback
            feedback_msg.distance_remaining = total_distance - distance_traveled
            feedback_msg.estimated_time = feedback_msg.distance_remaining / max_vel
            feedback_msg.current_pose = PoseStamped()
            feedback_msg.current_pose.pose.position.x = self.current_x
            feedback_msg.current_pose.pose.position.y = self.current_y
            feedback_msg.current_state = 'MOVING'
            
            goal_handle.publish_feedback(feedback_msg)
            
            # Simulate movement
            await self.sleep(0.1)
            distance_traveled += step_size
        
        # Goal succeeded
        goal_handle.succeed()
        
        result = Navigate.Result()
        result.success = True
        result.message = 'Navigation complete'
        result.total_distance = total_distance
        result.total_time = time.time() - start_time
        
        self.get_logger().info(
            f'Navigation complete: {total_distance:.2f}m in {result.total_time:.2f}s'
        )
        
        return result

    async def sleep(self, duration: float):
        """Non-blocking sleep."""
        import asyncio
        await asyncio.sleep(duration)


def main(args=None):
    rclpy.init(args=args)
    
    node = NavigationServer()
    executor = MultiThreadedExecutor()
    executor.add_node(node)
    
    try:
        executor.spin()
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()
```

---

## Action Client Implementation

```python title="navigation/navigation_client.py"
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle

from robot_interfaces.action import Navigate
from geometry_msgs.msg import PoseStamped


class NavigationClient(Node):
    """Action client for sending navigation goals."""

    def __init__(self):
        super().__init__('navigation_client')
        
        self._action_client = ActionClient(
            self,
            Navigate,
            'navigate'
        )
        
        self.get_logger().info('Navigation client initialized')

    def send_goal(self, x: float, y: float, velocity: float = 1.0):
        """Send a navigation goal."""
        
        # Wait for server
        self.get_logger().info('Waiting for action server...')
        self._action_client.wait_for_server()
        
        # Create goal
        goal_msg = Navigate.Goal()
        goal_msg.target_pose = PoseStamped()
        goal_msg.target_pose.pose.position.x = x
        goal_msg.target_pose.pose.position.y = y
        goal_msg.max_velocity = velocity
        goal_msg.avoid_obstacles = True
        
        self.get_logger().info(f'Sending goal: ({x}, {y}) at {velocity} m/s')
        
        # Send goal with callbacks
        self._send_goal_future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback
        )
        self._send_goal_future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future):
        """Handle goal acceptance/rejection."""
        goal_handle: ClientGoalHandle = future.result()
        
        if not goal_handle.accepted:
            self.get_logger().error('Goal rejected!')
            return
        
        self.get_logger().info('Goal accepted!')
        
        # Request result
        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.result_callback)

    def feedback_callback(self, feedback_msg):
        """Handle feedback during execution."""
        feedback = feedback_msg.feedback
        self.get_logger().info(
            f'Feedback: {feedback.distance_remaining:.2f}m remaining, '
            f'ETA: {feedback.estimated_time:.1f}s, '
            f'State: {feedback.current_state}'
        )

    def result_callback(self, future):
        """Handle final result."""
        result = future.result().result
        
        if result.success:
            self.get_logger().info(
                f'✅ {result.message}\n'
                f'   Distance: {result.total_distance:.2f}m\n'
                f'   Time: {result.total_time:.2f}s'
            )
        else:
            self.get_logger().warn(f'❌ {result.message}')


def main(args=None):
    rclpy.init(args=args)
    
    client = NavigationClient()
    client.send_goal(5.0, 3.0, velocity=1.5)
    
    rclpy.spin(client)
    client.destroy_node()
    rclpy.shutdown()
```

---

## Parameters: Runtime Configuration

### Declaring Parameters

```python title="robot_controller/configurable_node.py"
import rclpy
from rclpy.node import Node
from rcl_interfaces.msg import ParameterDescriptor, ParameterType


class ConfigurableNode(Node):
    """Node with runtime-configurable parameters."""

    def __init__(self):
        super().__init__('configurable_node')
        
        # Simple parameter declaration
        self.declare_parameter('robot_name', 'default_robot')
        
        # Parameter with descriptor (documentation, constraints)
        self.declare_parameter(
            'max_speed',
            1.0,
            ParameterDescriptor(
                description='Maximum robot speed in m/s',
                type=ParameterType.PARAMETER_DOUBLE,
                floating_point_range=[{
                    'from_value': 0.0,
                    'to_value': 5.0,
                    'step': 0.1
                }]
            )
        )
        
        # Integer parameter
        self.declare_parameter(
            'update_rate',
            10,
            ParameterDescriptor(
                description='Control loop rate in Hz',
                type=ParameterType.PARAMETER_INTEGER,
                integer_range=[{
                    'from_value': 1,
                    'to_value': 100,
                    'step': 1
                }]
            )
        )
        
        # Boolean parameter
        self.declare_parameter('debug_mode', False)
        
        # Read parameters
        self.robot_name = self.get_parameter('robot_name').value
        self.max_speed = self.get_parameter('max_speed').value
        self.update_rate = self.get_parameter('update_rate').value
        self.debug_mode = self.get_parameter('debug_mode').value
        
        self.get_logger().info(
            f'Configured: {self.robot_name}, '
            f'speed={self.max_speed}, '
            f'rate={self.update_rate}Hz'
        )
```

### Dynamic Parameter Updates

```python title="Parameter Callbacks"
from rcl_interfaces.msg import SetParametersResult


class DynamicConfigNode(Node):
    """Node that responds to parameter changes at runtime."""

    def __init__(self):
        super().__init__('dynamic_config_node')
        
        self.declare_parameter('gain_p', 1.0)
        self.declare_parameter('gain_i', 0.1)
        self.declare_parameter('gain_d', 0.01)
        
        # Register callback for parameter changes
        self.add_on_set_parameters_callback(self.parameter_callback)
        
        self.update_gains()

    def parameter_callback(self, params) -> SetParametersResult:
        """Called when parameters are changed externally."""
        
        for param in params:
            self.get_logger().info(
                f'Parameter change: {param.name} = {param.value}'
            )
            
            # Validate changes
            if param.name == 'gain_p' and param.value < 0:
                return SetParametersResult(
                    successful=False,
                    reason='gain_p must be non-negative'
                )
        
        # Apply changes
        self.update_gains()
        
        return SetParametersResult(successful=True)

    def update_gains(self):
        """Apply current parameter values."""
        self.kp = self.get_parameter('gain_p').value
        self.ki = self.get_parameter('gain_i').value
        self.kd = self.get_parameter('gain_d').value
        
        self.get_logger().info(f'PID gains: P={self.kp}, I={self.ki}, D={self.kd}')
```

### Parameter CLI Commands

```bash title="Terminal"
# List parameters for a node
ros2 param list /configurable_node

# Get parameter value
ros2 param get /configurable_node max_speed

# Set parameter value
ros2 param set /configurable_node max_speed 2.5

# Dump all parameters to file
ros2 param dump /configurable_node --output-dir ./

# Load parameters from file
ros2 param load /configurable_node params.yaml
```

### Parameter Files

```yaml title="config/robot_params.yaml"
configurable_node:
  ros__parameters:
    robot_name: "my_robot"
    max_speed: 2.0
    update_rate: 50
    debug_mode: true
    
    # Nested parameters
    pid:
      gain_p: 1.5
      gain_i: 0.2
      gain_d: 0.05
```

```bash title="Launch with parameters"
ros2 run robot_pkg configurable_node --ros-args \
    --params-file config/robot_params.yaml
```

---

## Summary

In this chapter, you learned:

- ✅ Actions handle long-running, preemptable tasks with feedback
- ✅ Action servers manage goal acceptance, execution, and cancellation
- ✅ Action clients send goals and handle async responses
- ✅ Parameters provide runtime configuration without code changes
- ✅ Parameter callbacks enable dynamic reconfiguration
- ✅ When to choose topics, services, or actions

---

## Exercises

### Exercise 1: Timed Action (Basic)

Create a `CountDown` action that:
1. Takes a `start_count` integer as goal
2. Counts down from `start_count` to 0
3. Sends feedback with current count every second
4. Returns total time elapsed as result

### Exercise 2: Cancellable Task (Intermediate)

Modify the navigation action to:
1. Support "pause" by setting a parameter
2. Resume when parameter is cleared
3. Handle timeout (fail if goal takes > 60 seconds)
4. Publish progress to a topic for visualization

### Exercise 3: Adaptive Parameters (Advanced)

Create a node that:
1. Automatically adjusts `max_speed` based on battery level
2. Monitors `/battery_level` topic
3. Reduces speed when battery < 30%
4. Logs all parameter changes with timestamps
5. Persists parameter history to a file

---

## References

1. [ROS 2 Actions](https://docs.ros.org/en/humble/Tutorials/Intermediate/Writing-an-Action-Server-Client/Py.html)
2. [Using Parameters](https://docs.ros.org/en/humble/Tutorials/Beginner-Client-Libraries/Using-Parameters-In-A-Class-Python.html)
3. [ROS 2 Parameters Design](https://design.ros2.org/articles/ros_parameters.html)
4. [Action Design](https://design.ros2.org/articles/actions.html)
